"""XMPP BOSH Client"""
import requests
import xml.etree.ElementTree as ET
import base64
import random
from pathlib import Path
from typing import Optional, Callable

from .accounts import AccountManager
from .userlist import UserList
from .messages import MessageParser


class XMPPClient:
    """XMPP BOSH Client"""
   
    def __init__(self, config_path: str = None):
        if config_path is None:
            config_path = Path(__file__).parent / ".." / "settings/config.json"
       
        self.account_manager = AccountManager(str(config_path))
        self.connected_account = None
        self.rid = int(random.random() * 1e10)
        self.sid = None
        self.jid = None
       
        self.message_callback: Optional[Callable] = None
        self.presence_callback: Optional[Callable] = None
       
        self.user_list = UserList()
        self.initial_roster_received = False
       
        server = self.account_manager.get_server_config()
        self.url = server.get('url')
        self.domain = server.get('domain')
        self.resource = server.get('resource')
       
        if not self.url or not self.domain:
            raise RuntimeError("‚ùå Invalid config")
       
        conn = self.account_manager.get_connection_config()
        self.conn_params = {
            'xml:lang': conn.get('lang', 'en'),
            'wait': conn.get('wait', '60'),
            'hold': conn.get('hold', '1'),
            'content': conn.get('content_type', 'text/xml; charset=utf-8'),
            'ver': conn.get('version', '1.6'),
            'xmpp:version': conn.get('xmpp_version', '1.0')
        }
       
        self.headers = {
            'Content-Type': 'text/xml; charset=UTF-8',
            'Origin': 'https://klavogonki.ru',
            'Referer': 'https://klavogonki.ru/gamelist/',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Connection': 'keep-alive'
        }
       
        self.session = requests.Session()
        self.session.headers.update(self.headers)
   
    def set_message_callback(self, callback: Callable):
        """Set message callback"""
        self.message_callback = callback
   
    def set_presence_callback(self, callback: Callable):
        """Set presence callback"""
        self.presence_callback = callback

    def _get_effective_background(self) -> Optional[str]:
        """Get effective background: custom if exists, otherwise server background"""
        if self.connected_account is None:
            return None
        return self.connected_account.get('custom_background') or self.connected_account.get('background')
   
    def build_body(self, children=None, **attrs):
        """Build BOSH body"""
        body = ET.Element('body', {
            'rid': str(self.rid),
            'xmlns': 'http://jabber.org/protocol/httpbind',
            **{k: v for k, v in attrs.items() if v is not None}
        })
        if self.sid:
            body.set('sid', self.sid)
        if any(k.startswith('xmpp:') for k in attrs):
            body.set('xmlns:xmpp', 'urn:xmpp:xbosh')
        if children:
            for child in children:
                body.append(child)
        return ET.tostring(body, encoding='utf-8').decode('utf-8')
   
    def send_request(self, payload, verbose: bool = True, timeout: int = 10):
        """Send request with configurable timeout"""
        if verbose:
            print(f"\nüì§ {payload[:100]}...")
       
        response = self.session.post(self.url, data=payload, timeout=timeout)
        response.raise_for_status()
       
        if verbose:
            print(f"üì• {response.text[:100]}...")
        return response.text
   
    def parse_xml(self, xml_text):
        """Parse XML"""
        try:
            return ET.fromstring(xml_text)
        except ET.ParseError as e:
            print(f"‚ùå Parse error: {e}")
            return None
   
    def connect(self, account=None):
        """Connect to XMPP"""
        if account is None:
            account = self.account_manager.get_active_account()
        elif isinstance(account, str):
            account = self.account_manager.get_account_by_chat_username(account)
       
        if not account:
            print("‚ùå No account")
            return False
       
        self.connected_account = account
       
        print(f"üîë Connecting: {account['chat_username']}")
       
        user_id = account['user_id']
        chat_username = account['chat_username']
        chat_password = account['chat_password']
       
        try:
            # Initialize session
            payload = self.build_body(to=self.domain, **self.conn_params)
            root = self.parse_xml(self.send_request(payload, verbose=False, timeout=10))
            if root is not None:
                self.sid = root.get('sid')
                print(f"‚úÖ Connected - SID: {self.sid}")
           
            if not self.sid:
                return False
           
            # Auth
            self.rid += 1
            authcid = f'{user_id}#{chat_username}'
            auth_str = f'\0{authcid}\0{chat_password}'
            auth_b64 = base64.b64encode(auth_str.encode('utf-8')).decode('ascii')
           
            auth_elem = ET.Element('auth', {
                'xmlns': 'urn:ietf:params:xml:ns:xmpp-sasl',
                'mechanism': 'PLAIN'
            })
            auth_elem.text = auth_b64
           
            self.send_request(self.build_body(children=[auth_elem]), verbose=False, timeout=10)
           
            # Restart stream
            self.rid += 1
            payload = self.build_body(**{
                'xmpp:restart': 'true',
                'to': self.domain,
                'xml:lang': 'en'
            })
            self.send_request(payload, verbose=False, timeout=10)
           
            # Bind resource
            self.rid += 1
            iq = ET.Element('iq', {'type': 'set', 'id': 'bind_1', 'xmlns': 'jabber:client'})
            bind = ET.SubElement(iq, 'bind', {'xmlns': 'urn:ietf:params:xml:ns:xmpp-bind'})
            ET.SubElement(bind, 'resource').text = self.resource
           
            root = self.parse_xml(self.send_request(self.build_body(children=[iq]), verbose=False, timeout=10))
            if root is not None:
                jid_el = root.find('.//{urn:ietf:params:xml:ns:xmpp-bind}jid')
                if jid_el is not None:
                    self.jid = jid_el.text
                    print(f"‚úÖ Authenticated")
           
            if not self.jid:
                return False
           
            # Session
            self.rid += 1
            iq = ET.Element('iq', {'type': 'set', 'id': 'session_1', 'xmlns': 'jabber:client'})
            ET.SubElement(iq, 'session', {'xmlns': 'urn:ietf:params:xml:ns:xmpp-session'})
            self.send_request(self.build_body(children=[iq]), verbose=False, timeout=10)
           
            return True
           
        except requests.Timeout:
            print("‚ùå Connection timeout")
            return False
        except Exception as e:
            print(f"‚ùå Connection error: {e}")
            return False
   
    def join_room(self, room_jid, nickname=None):
        """Join MUC room"""
        if not hasattr(self, '_joined_rooms'):
            self._joined_rooms = set()
        if room_jid in self._joined_rooms:
            print(f"‚ÑπÔ∏è Already joined: {room_jid}")
            return
       
        if self.connected_account is None:
            print("‚ùå No connected account")
            return
       
        if nickname is None:
            nickname = f"{self.connected_account['user_id']}#{self.connected_account['chat_username']}"
       
        self.rid += 1
        presence = ET.Element('presence', {
            'xmlns': 'jabber:client',
            'to': f'{room_jid}/{nickname}'
        })
        ET.SubElement(presence, 'x', {'xmlns': 'http://jabber.org/protocol/muc'})
       
        # Add user data with avatar and background
        x_data = ET.SubElement(presence, 'x', {'xmlns': 'klavogonki:userdata'})
        user = ET.SubElement(x_data, 'user')
        ET.SubElement(user, 'login').text = self.connected_account['chat_username']
        
        # Add avatar if available
        if self.connected_account.get('avatar'):
            ET.SubElement(user, 'avatar').text = self.connected_account['avatar']
        
        # Use effective background (custom if exists, otherwise server)
        bg = self._get_effective_background()
        if bg:
            ET.SubElement(user, 'background').text = bg
       
        try:
            response = self.send_request(self.build_body(children=[presence]), verbose=False, timeout=15)
           
            self.initial_roster_received = False
            self._process_response(response, is_initial_roster=True)
            self.initial_roster_received = True
            self._joined_rooms.add(room_jid)
            print(f"‚úÖ Joined room")
           
        except requests.Timeout:
            print("‚ùå Join timeout")
        except Exception as e:
            print(f"‚ùå Join error: {e}")
   
    def send_message(self, body: str, to_jid: str = None, msg_type: str = 'groupchat'):
        """Send message - supports both groupchat and private chat"""
        if not self.sid or not self.jid:
            return False
       
        if self.connected_account is None:
            return False
       
        # Determine recipient
        if to_jid is None and msg_type == 'groupchat':
            # Find default room for group chat
            rooms = self.account_manager.get_rooms()
            for room in rooms:
                if room.get('auto_join'):
                    to_jid = room['jid']
                    break
       
        if not to_jid:
            return False
       
        self.rid += 1
       
        # Create message element
        message = ET.Element('message', {
            'xmlns': 'jabber:client',
            'to': to_jid,
            'type': msg_type,
            'from': self.jid
        })
        ET.SubElement(message, 'body').text = body
       
        # Add userdata
        x_data = ET.SubElement(message, 'x', {'xmlns': 'klavogonki:userdata'})
        user = ET.SubElement(x_data, 'user')
        ET.SubElement(user, 'login').text = self.connected_account['chat_username']
       
        # Add avatar if available
        if self.connected_account.get('avatar'):
            ET.SubElement(user, 'avatar').text = self.connected_account['avatar']
        
        # Use effective background (custom if exists, otherwise server)
        bg = self._get_effective_background()
        if bg:
            ET.SubElement(user, 'background').text = bg
       
        try:
            payload = self.build_body(children=[message])
            response = self.send_request(payload, verbose=False, timeout=5)
            return True
        except Exception as e:
            print(f"‚ùå Send error: {e}")
            return False
   
    def _process_response(self, xml_text: str, is_initial_roster: bool = False):
        """Process response"""
        messages, presence_updates = MessageParser.parse(xml_text)
        
        # Override own background in received messages and presence
        effective_bg = self._get_effective_background()
        own_username = self.connected_account.get('chat_username') if self.connected_account else None
        
        if own_username and effective_bg:
            for collection in (messages, presence_updates):
                for item in collection:
                    if item.login == own_username:
                        item.background = effective_bg
       
        for msg in messages:
            try:
                msg.initial = bool(is_initial_roster)
            except Exception:
                msg.initial = False

            body = (msg.body or "").strip()
            # Skip only the anonymous room notification message
            if 'not anonymous' in body.lower():
                continue
           
            if self.message_callback:
                self.message_callback(msg)
       
        for pres in presence_updates:
            # Skip bot from userlist
            if pres.login == '–ö–ª–∞–≤–æ–±–æ—Ç':
                continue
           
            if pres.presence_type == 'available':
                existing_user = self.user_list.get(pres.from_jid)
                is_new_user = existing_user is None
               
                old_game_id = existing_user.game_id if existing_user else None
                new_game_id = pres.game_id
               
                self.user_list.add_or_update(
                    jid=pres.from_jid,
                    login=pres.login,
                    user_id=pres.user_id,
                    background=pres.background,
                    game_id=pres.game_id,
                    affiliation=pres.affiliation,
                    role=pres.role
                )
               
                if not is_initial_roster and self.initial_roster_received:
                    login = pres.login if pres.login else pres.from_jid.split('/')[-1]
                   
                    if is_new_user:
                        print(f"‚ûï {login} joined")
                    elif old_game_id is None and new_game_id:
                        print(f"üöÄ {login} ‚Üí game #{new_game_id}")
                    elif old_game_id and new_game_id is None:
                        print(f"üèÅ {login} left game")
                    elif old_game_id and new_game_id and old_game_id != new_game_id:
                        print(f"üöÄ {login} ‚Üí game #{new_game_id}")
               
                if self.presence_callback:
                    self.presence_callback(pres)
                   
            elif pres.presence_type == 'unavailable':
                existing_user = self.user_list.get(pres.from_jid)
                self.user_list.remove(pres.from_jid)
               
                if self.initial_roster_received and existing_user and not is_initial_roster:
                    login = pres.login if pres.login else pres.from_jid.split('/')[-1]
                    print(f"‚ûñ {login} left")
               
                if self.presence_callback:
                    self.presence_callback(pres)
   
    def listen(self):
        """Listen for messages"""
        print("üì° Listening...\n")
       
        try:
            while True:
                self.rid += 1
                response = self.send_request(self.build_body(), verbose=False, timeout=70)
               
                root = self.parse_xml(response)
                if root is not None:
                    if root.get('type') == 'terminate':
                        print("\n‚ö†Ô∏è Terminated")
                        break
                   
                    self._process_response(response)
       
        except KeyboardInterrupt:
            print("\nüëã Bye")
        except Exception as e:
            print(f"\n‚ùå Error: {e}")
   
    def disconnect(self):
        """Disconnect"""
        if self.sid:
            try:
                self.rid += 1
                self.send_request(self.build_body(type='terminate'), verbose=False, timeout=5)
            except:
                pass
            finally:
                self.sid = None
                self.jid = None
                self.connected_account = None
                if hasattr(self, 'session'):
                    self.session.close()